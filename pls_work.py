import math


# ----------------------------
# Категория и переменное кодирование значений
# ----------------------------

def get_category(value):
    if value == 0:
        return 0
    return int(math.floor(math.log2(abs(value)))) + 1


def encode_value(value, category):
    if category == 0:
        return 0
    if value >= 0:
        return value
    else:
        return (1 << category) + value - 1  # инвертированные биты


def decode_value(bits, category):
    if category == 0:
        return 0
    if bits >= (1 << (category - 1)):
        return bits
    else:
        return bits - (1 << category) + 1


# ----------------------------
# BitStream writer/reader
# ----------------------------

class BitStream:
    def __init__(self):
        self.bits = []
        self.byte_array = bytearray()

    def write_bits(self, value, length):
        for i in reversed(range(length)):
            self.bits.append((value >> i) & 1)
        self._flush()

    def _flush(self):
        while len(self.bits) >= 8:
            byte = 0
            for _ in range(8):
                byte = (byte << 1) | self.bits.pop(0)
            self.byte_array.append(byte)

    def flush_final(self):
        if self.bits:
            byte = 0
            for _ in range(8):
                if self.bits:
                    byte = (byte << 1) | self.bits.pop(0)
                else:
                    byte <<= 1
            self.byte_array.append(byte)

    def get_bytes(self):
        return bytes(self.byte_array)


class BitReader:
    def __init__(self, data):
        self.data = data
        self.bitpos = 0

    def read_bit(self):
        byte_index = self.bitpos // 8
        bit_index = 7 - (self.bitpos % 8)
        self.bitpos += 1
        return (self.data[byte_index] >> bit_index) & 1

    def read_bits(self, count):
        result = 0
        for _ in range(count):
            result = (result << 1) | self.read_bit()
        return result


# ----------------------------
# RLE кодирование AC
# ----------------------------

def rle_ac(ac_coeffs):
    result = []
    zero_run = 0
    for val in ac_coeffs:
        if val == 0:
            zero_run += 1
            if zero_run == 16:
                result.append((15, 0, 0))  # ZRL
                zero_run = 0
        else:
            cat = get_category(val)
            bits = encode_value(val, cat)
            result.append((zero_run, cat, bits))
            zero_run = 0
    if zero_run > 0:
        result.append((0, 0, 0))  # EOB
    return result


# ----------------------------
# Хаффман-таблицы
# ----------------------------

huffman_dc = {
    0: (0b00, 2),
    1: (0b010, 3),
    2: (0b011, 3),
    3: (0b100, 3),
    4: (0b101, 3),
    5: (0b110, 3),
    6: (0b1110, 4),
    7: (0b11110, 5),
    8: (0b111110, 6),
    9: (0b1111110, 7),
    10: (0b11111110, 8),
    11: (0b111111110, 9)
}

huffman_ac = {
    (0, 0): (0b1010, 4),
    (0, 1): (0b00, 2),
    (0, 2): (0b01, 2),
    (0, 3): (0b100, 3),
    (0, 4): (0b1011, 4),
    (0, 5): (0b11010, 5),
    (0, 6): (0b1111000, 7),
    (0, 7): (0b11111000, 8),
    (0, 8): (0b1111110110, 10),
    (0, 9): (0b1111111110000010, 16),
    (0, 10): (0b1111111110000011, 16),
    (1, 1): (0b1100, 4),
    (1, 2): (0b11011, 5),
    (1, 3): (0b1111001, 7),
    (1, 4): (0b111110110, 9),
    (1, 5): (0b11111110110, 11),
    (1, 6): (0b1111111110000100, 16),
    (1, 7): (0b1111111110000101, 16),
    (1, 8): (0b1111111110000110, 16),
    (1, 9): (0b1111111110000111, 16),
    (1, 10): (0b1111111110001000, 16),
    (2, 1): (0b11100, 5),
    (2, 2): (0b11111001, 8),
    (2, 3): (0b1111110111, 10),
    (2, 4): (0b111111110100, 12),
    (2, 5): (0b1111111110001001, 16),
    (2, 6): (0b1111111110001010, 16),
    (2, 7): (0b1111111110001011, 16),
    (2, 8): (0b1111111110001100, 16),
    (2, 9): (0b1111111110001101, 16),
    (2, 10): (0b1111111110001110, 16),
    (3, 1): (0b111010, 6),
    (3, 2): (0b111110111, 9),
    (3, 3): (0b111111110101, 12),
    (3, 4): (0b1111111110001111, 16),
    (3, 5): (0b1111111110010000, 16),
    (3, 6): (0b1111111110010001, 16),
    (3, 7): (0b1111111110010010, 16),
    (3, 8): (0b1111111110010011, 16),
    (3, 9): (0b1111111110010100, 16),
    (3, 10): (0b1111111110010101, 16),
    (4, 1): (0b111011, 6),
    (4, 2): (0b1111111000, 10),
    (4, 3): (0b1111111110010110, 16),
    (4, 4): (0b1111111110010111, 16),
    (4, 5): (0b1111111110011000, 16),
    (4, 6): (0b1111111110011001, 16),
    (4, 7): (0b1111111110011010, 16),
    (4, 8): (0b1111111110011011, 16),
    (4, 9): (0b1111111110011100, 16),
    (4, 10): (0b1111111110011101, 16),
    (5, 1): (0b1111010, 7),
    (5, 2): (0b11111110111, 11),
    (5, 3): (0b1111111110011110, 16),
    (5, 4): (0b1111111110011111, 16),
    (5, 5): (0b1111111110100000, 16),
    (5, 6): (0b1111111110100001, 16),
    (5, 7): (0b1111111110100010, 16),
    (5, 8): (0b1111111110100011, 16),
    (5, 9): (0b1111111110100100, 16),
    (5, 10): (0b1111111110100101, 16),
    (6, 1): (0b1111011, 7),
    (6, 2): (0b111111110110, 12),
    (6, 3): (0b1111111110100110, 16),
    (6, 4): (0b1111111110100111, 16),
    (6, 5): (0b1111111110101000, 16),
    (6, 6): (0b1111111110101001, 16),
    (6, 7): (0b1111111110101010, 16),
    (6, 8): (0b1111111110101011, 16),
    (6, 9): (0b1111111110101100, 16),
    (6, 10): (0b1111111110101101, 16),
    (7, 1): (0b11111010, 8),
    (7, 2): (0b111111110111, 12),
    (7, 3): (0b1111111110101110, 16),
    (7, 4): (0b1111111110101111, 16),
    (7, 5): (0b1111111110110000, 16),
    (7, 6): (0b1111111110110001, 16),
    (7, 7): (0b1111111110110010, 16),
    (7, 8): (0b1111111110110011, 16),
    (7, 9): (0b1111111110110100, 16),
    (7, 10): (0b1111111110110101, 16),
    (8, 1): (0b111111000, 9),
    (8, 2): (0b111111111000000, 15),
    (8, 3): (0b1111111110110110, 16),
    (8, 4): (0b1111111110110111, 16),
    (8, 5): (0b1111111110111000, 16),
    (8, 6): (0b1111111110111001, 16),
    (8, 7): (0b1111111110111010, 16),
    (8, 8): (0b1111111110111011, 16),
    (8, 9): (0b1111111110111100, 16),
    (8, 10): (0b1111111110111101, 16),
    (9, 1): (0b111111001, 9),
    (9, 2): (0b1111111110111110, 16),
    (9, 3): (0b1111111110111111, 16),
    (9, 4): (0b1111111111000000, 16),
    (9, 5): (0b1111111111000001, 16),
    (9, 6): (0b1111111111000010, 16),
    (9, 7): (0b1111111111000011, 16),
    (9, 8): (0b1111111111000100, 16),
    (9, 9): (0b1111111111000101, 16),
    (9, 10): (0b1111111111000110, 16),
    (10, 1): (0b111111010, 9),
    (10, 2): (0b1111111111000111, 16),
    (10, 3): (0b1111111111001000, 16),
    (10, 4): (0b1111111111001001, 16),
    (10, 5): (0b1111111111001010, 16),
    (10, 6): (0b1111111111001011, 16),
    (10, 7): (0b1111111111001100, 16),
    (10, 8): (0b1111111111001101, 16),
    (10, 9): (0b1111111111001110, 16),
    (10, 10): (0b1111111111001111, 16),
    (15, 0): (0b11111111001, 11),  # ZRL
}

huffman_dc_chrominance = {
    0: (0b00, 2),
    1: (0b00, 2),
    2: (0b01, 2),
    3: (0b10, 3),
    4: (0b110, 4),
    5: (0b1110, 5),
    6: (0b11110, 6),
    7: (0b111110, 7),
    8: (0b1111110, 8),
    9: (0b11111110, 9),
    10: (0b1111111110, 10),
    11: (0b11111111110, 11)
}

huffman_ac_chrominance = {
    (0, 0): (0b00, 2),  # EOB
    (0, 1): (0b01, 2),
    (0, 2): (0b100, 3),
    (0, 3): (0b1010, 4),
    (0, 4): (0b11000, 5),
    (0, 5): (0b11001, 5),
    (0, 6): (0b111000, 6),
    (0, 7): (0b1111000, 7),
    (0, 8): (0b111110100, 9),
    (0, 9): (0b111111010, 10),
    (0, 10): (0b11111110100, 12),  # 0/A

    (1, 1): (0b1011, 4),
    (1, 2): (0b111001, 6),
    (1, 3): (0b11110110, 8),
    (1, 4): (0b111110101, 9),
    (1, 5): (0b1111110110, 11),
    (1, 6): (0b11111110101, 12),
    (1, 7): (0b111111110001000, 16),
    (1, 8): (0b111111110001001, 16),
    (1, 9): (0b111111110001010, 16),
    (1, 10): (0b111111110001011, 16),  # 1/A

    (2, 1): (0b11010, 5),
    (2, 2): (0b11110111, 8),
    (2, 3): (0b1111110111, 10),
    (2, 4): (0b11111110110, 12),
    (2, 5): (0b11111111000010, 15),
    (2, 6): (0b111111110001100, 16),
    (2, 7): (0b111111110001101, 16),
    (2, 8): (0b111111110001110, 16),
    (2, 9): (0b111111110001111, 16),
    (2, 10): (0b111111110010000, 16),  # 2/A

    (3, 1): (0b11011, 5),
    (3, 2): (0b11111000, 8),
    (3, 3): (0b1111111000, 10),
    (3, 4): (0b11111110111, 12),
    (3, 5): (0b111111110010001, 16),
    (3, 6): (0b111111110010010, 16),
    (3, 7): (0b111111110010011, 16),
    (3, 8): (0b111111110010100, 16),
    (3, 9): (0b111111110010101, 16),
    (3, 10): (0b111111110010110, 16),  # 3/A

    (4, 1): (0b111010, 6),
    (4, 2): (0b111110110, 9),
    (4, 3): (0b11111111010111, 16),
    (4, 4): (0b111111110011000, 16),
    (4, 5): (0b111111110011001, 16),
    (4, 6): (0b111111110011010, 16),
    (4, 7): (0b111111110011011, 16),
    (4, 8): (0b111111110011100, 16),
    (4, 9): (0b111111110011101, 16),
    (4, 10): (0b111111110011110, 16),  # 4/A

    (5, 1): (0b111011, 6),
    (5, 2): (0b1111111001, 10),
    (5, 3): (0b111111110011111, 16),
    (5, 4): (0b111111110100000, 16),
    (5, 5): (0b111111110100001, 16),
    (5, 6): (0b111111110100010, 16),
    (5, 7): (0b111111110100011, 16),
    (5, 8): (0b111111110100100, 16),
    (5, 9): (0b111111110100101, 16),
    (5, 10): (0b111111110100110, 16),  # 5/A

    (6, 1): (0b111001, 7),  # Примечание: дубликат с (1,2), вероятно ошибка в таблице
    (6, 2): (0b1111110111, 11),
    (6, 3): (0b111111110100111, 16),
    (6, 4): (0b111111110101000, 16),
    (6, 5): (0b111111110101001, 16),
    (6, 6): (0b111111110101010, 16),
    (6, 7): (0b111111110101011, 16),
    (6, 8): (0b111111110101100, 16),
    (6, 9): (0b111111110101101, 16),
    (6, 10): (0b111111110101110, 16),  # 6/A

    (7, 1): (0b111010, 7),  # Примечание: дубликат с (4,1), но разная длина
    (7, 2): (0b1111111000, 11),
    (7, 3): (0b111111110101111, 16),
    (7, 4): (0b111111110110000, 16),
    (7, 5): (0b111111110110001, 16),
    (7, 6): (0b111111110110010, 16),
    (7, 7): (0b111111110110011, 16),
    (7, 8): (0b111111110110100, 16),
    (7, 9): (0b111111110110101, 16),
    (7, 10): (0b111111110110110, 16),  # 7/A

    (8, 1): (0b11111001, 8),
    (8, 2): (0b111111110110111, 16),
    (8, 3): (0b111111110110000, 16),  # Примечание: дубликат с (7,4)
    (8, 4): (0b1111111110111001, 16),
    (8, 5): (0b1111111110111010, 16),
    (8, 6): (0b1111111110111011, 16),
    (8, 7): (0b1111111110111100, 16),
    (8, 8): (0b1111111110111101, 16),
    (8, 9): (0b1111111110111110, 16),
    (8, 10): (0b1111111110111111, 16),  # 8/A

    (9, 1): (0b1111110111, 9),
    (9, 2): (0b1111111110000000, 16),
    (9, 3): (0b111111111000001, 15),  # Неполный код (должен быть 16 бит)
    (9, 4): (0b1111111110000100, 16),
    (9, 5): (0b1111111110000110, 16),
    (9, 6): (0b1111111110001000, 16),
    (9, 7): (0b1111111110001010, 16),
    (9, 8): (0b1111111110001100, 16),
    (9, 9): (0b1111111110001111, 16),
    (9, 10): (0b1111111110001000, 16),  # 9/A (дубликат с 9/6)

    (10, 1): (0b111111000, 9),  # A/1
    (10, 2): (0b111111111001001, 15),  # A/2 (неполный код)
    (10, 3): (0b1111111110010100, 16),  # A/3
    (10, 4): (0b1111111110010110, 16),
    (10, 5): (0b1111111110011000, 16),
    (10, 6): (0b1111111110011010, 16),
    (10, 7): (0b1111111110011100, 16),
    (10, 8): (0b1111111110011110, 16),
    (10, 9): (0b1111111110010000, 16),
    (10, 10): (0b1111111110010001, 16),  # A/A

    (11, 1): (0b111111001, 9),  # B/1
    (11, 2): (0b1111111110010100, 16),  # B/2 (дубликат с A/3)
    (11, 3): (0b1111111110010110, 16),  # B/3 (дубликат с A/4)
    (11, 4): (0b1111111110010000, 16),  # B/4 (дубликат с A/9)
    (11, 5): (0b1111111110011010, 16),  # B/5 (дубликат с A/6)
    (11, 6): (0b1111111110011010, 16),  # B/6 (дубликат с B/5)
    (11, 7): (0b1111111110011110, 16),  # B/7 (дубликат с A/8)
    (11, 8): (0b1111111110011000, 16),  # B/8 (дубликат с A/5)
    (11, 9): (0b1111111110011001, 16),  # B/9
    (11, 10): (0b1111111110011010, 16),  # B/A (дубликат с B/5)

    (12, 1): (0b111111010, 9),  # C/1
    (12, 2): (0b1111111110011011, 16),  # C/2
    (12, 3): (0b1111111110011000, 16),  # C/3 (дубликат с A/5)
    (12, 4): (0b1111111110011011, 16),  # C/4 (дубликат с C/2)
    (12, 5): (0b1111111110011100, 16),  # C/5 (дубликат с A/7)
    (12, 6): (0b111111111011111, 15),  # C/6 (неполный код)
    (12, 7): (0b11111111100000, 14),  # C/7 (неполный код)
    (12, 8): (0b11111111100001, 15),  # C/8 (неполный код)
    (12, 9): (0b11111111100010, 15),  # C/9 (неполный код)
    (12, 10): (0b111111111100011, 16),  # C/A

    (13, 1): (0b11111111001, 11),  # D/1
    (13, 2): (0b11111111100100, 15),  # D/2 (неполный код)
    (13, 3): (0b11111111100101, 15),  # D/3 (неполный код)
    (13, 4): (0b11111111100110, 15),  # D/4 (неполный код)
    (13, 5): (0b11111111100111, 15),  # D/5 (неполный код)
    (13, 6): (0b11111111101000, 15),  # D/6 (неполный код)
    (13, 7): (0b11111111101001, 15),  # D/7 (неполный код)
    (13, 8): (0b11111111101010, 15),  # D/8 (неполный код)
    (13, 9): (0b11111111101011, 15),  # D/9 (неполный код)
    (13, 10): (0b111111111101100, 16),  # D/A

    (14, 1): (0b11111111100000, 14),  # E/1 (дубликат с C/7)
    (14, 2): (0b111111111101101, 16),  # E/2
    (14, 3): (0b111111111101110, 16),  # E/3
    (14, 4): (0b111111111101111, 16),  # E/4
    (14, 5): (0b111111111110000, 16),  # E/5
    (14, 6): (0b111111111110001, 16),  # E/6
    (14, 7): (0b111111111110010, 16),  # E/7
    (14, 8): (0b111111111110011, 16),  # E/8
    (14, 9): (0b111111111110100, 16),  # E/9
    (14, 10): (0b111111111110101, 16),

    (15, 0): (0b11111111010, 10),
    (15, 1): (0b111111111000011, 15),
    (15, 2): (0b111111111110110, 16),
    (15, 3): (0b111111111110111, 16),
    (15, 4): (0b111111111111000, 16),
    (15, 5): (0b111111111111001, 16),
    (15, 6): (0b111111111111010, 16),
    (15, 7): (0b111111111111001, 16),
    (15, 8): (0b111111111111100, 16),
    (15, 9): (0b111111111111101, 16),
    (15, 10): (0b111111111111110, 16),
}
# Обратные таблицы Хаффмана для декодирования
inv_huffman_dc = {format(code, f'0{length}b'): size for size, (code, length) in huffman_dc.items()}
inv_huffman_ac = {format(code, f'0{length}b'): (run, size) for (run, size), (code, length) in huffman_ac.items()}

# Обратные таблицы Хаффмана для декодирования хроминансных коэффициентов
inv_huffman_dc_chrominance = {format(code, f'0{length}b'): size for size, (code, length) in
                              huffman_dc_chrominance.items()}
inv_huffman_ac_chrominance = {format(code, f'0{length}b'): (run, size) for (run, size), (code, length) in
                              huffman_ac_chrominance.items()}


# ----------------------------
# Кодирование JPEG блоков
# ----------------------------

def encode_blocks(blocks, chrominance=False):
    bitstream = BitStream()
    height, width = blocks[0]
    blocks = blocks[1:]
    num_blocks = len(blocks)

    # Write image info (height, width, num_blocks) — 2 bytes each
    header = height.to_bytes(2, 'big') + width.to_bytes(2, 'big') + num_blocks.to_bytes(2, 'big')

    prev_dc = 0
    for block in blocks:
        dc = block[0]
        dc_diff = dc - prev_dc
        prev_dc = dc

        cat = get_category(dc_diff)

        # Выбор таблицы Хаффмана для luminance или chrominance
        if chrominance:
            huffman_dc_table = huffman_dc_chrominance
        else:
            huffman_dc_table = huffman_dc

        dc_code, dc_len = huffman_dc_table[cat]
        dc_bits = encode_value(dc_diff, cat)

        bitstream.write_bits(dc_code, dc_len)
        bitstream.write_bits(dc_bits, cat)

        ac_encoded = rle_ac(block[1:])
        for run, size, val_bits in ac_encoded:
            # Выбор таблицы Хаффмана для luminance или chrominance
            if chrominance:
                huffman_ac_table = huffman_ac_chrominance
            else:
                huffman_ac_table = huffman_ac

            ac_code, ac_len = huffman_ac_table.get((run, size), (0, 0))
            bitstream.write_bits(ac_code, ac_len)
            if size > 0:
                bitstream.write_bits(val_bits, size)

    bitstream.flush_final()
    return header + bitstream.get_bytes()


# ----------------------------
# Декодирование JPEG блоков
# ----------------------------

def decode_blocks(encoded: bytes, chrominance=False):
    # Read header
    height = int.from_bytes(encoded[0:2], 'big')
    width = int.from_bytes(encoded[2:4], 'big')
    num_blocks = int.from_bytes(encoded[4:6], 'big')
    data = encoded[6:]

    reader = BitReader(data)
    blocks = []

    prev_dc = 0
    for _ in range(num_blocks):
        # Decode DC
        if chrominance:
            huffman_dc_table = inv_huffman_dc_chrominance
        else:
            huffman_dc_table = inv_huffman_dc

        dc_cat = read_huffman_code(reader, huffman_dc_table)
        dc_bits = reader.read_bits(dc_cat)
        dc_diff = decode_value(dc_bits, dc_cat)
        dc = prev_dc + dc_diff
        prev_dc = dc

        ac = []
        total_ac = 0
        while total_ac < 63:
            if chrominance:
                huffman_ac_table = inv_huffman_ac_chrominance
            else:
                huffman_ac_table = inv_huffman_ac

            run, size = read_huffman_code(reader, huffman_ac_table)
            if (run, size) == (0, 0):  # EOB
                while len(ac) < 63:
                    ac.append(0)
                break
            elif (run, size) == (15, 0):  # ZRL
                ac.extend([0] * 16)
                total_ac += 16
            else:
                ac.extend([0] * run)
                val_bits = reader.read_bits(size)
                value = decode_value(val_bits, size)
                ac.append(value)
                total_ac = len(ac)
        while len(ac) < 63:
            ac.append(0)
        blocks.append([dc] + ac)

    return [(height, width)] + blocks


def read_huffman_code(reader, inv_table, max_bits=16):
    bits = ''
    for _ in range(max_bits):
        bit = str(reader.read_bit())
        bits += bit
        if bits in inv_table:
            return inv_table[bits]
    raise ValueError(f"Invalid Huffman code: {bits}")
